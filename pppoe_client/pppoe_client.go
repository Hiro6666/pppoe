package main

import (
	"bytes"
	"context"
	"encoding/binary"
	"errors"
	"fmt"
	"log"
	"net"
	"sort"
	"time"

	"github.com/mdlayher/raw"
)

// Constants for PPPoE protocol EtherTypes.
const (
	protoPPPoEDiscovery = 0x8863
	protoPPPoESession   = 0x8864
)

// Constants for PPPoE Discovery packet types.
const (
	pppoePADI = 0x09 // "Hey, any PPPoE concentrators out there?
	pppoePADO = 0x07 // "Hi, I'm a PPPoE concentrator"
	pppoePADR = 0x19 // "Cool, can we set up a PPPoE session?"
	pppoePADS = 0x65 // "Done, here's the session ID!"
	pppoePADT = 0xa7 // "I'm tearing down our session"
)

// Constants for PPPoE Discovery tag types
const (
	pppoeTagServiceName = 0x0101 // Roughly speaking, the name of the ISP.
	pppoeTagACName      = 0x0102 // Roughly speaking, the hostname of the PPPoE concentrator.
	pppoeTagCookie      = 0x0104 // The PPPoE equivalent of a syncookie.
	pppoeTagHostUniq    = 0x0103 // A unique identifier generated by the client.
)

// pppoeBufferLen is the maximum size of a PPPoE packet. The spec says
// that PPPoE packets may not exceed the ethernet MTU, which is 1500.
const pppoeBufferLen = 1500

func main() {
	// 创建PPPoE发现连接
	conn, err := newDiscoveryConn("ens33")
	if err != nil {
		log.Fatalf("Failed to create discovery connection: %v", err)
	}
	defer conn.Close()

	log.Println("PPPoE client is running...")

	// 执行PPPoE发现过程
	concentrator, sessionID, err := pppoeDiscovery(context.Background(), conn)
	if err != nil {
		log.Fatalf("PPPoE discovery failed: %v", err)
	}

	// 输出成功建立的会话信息
	log.Printf("PPPoE session established with concentrator: %s, Session ID: %d", concentrator, sessionID)

	// 程序结束前等待一段时间，确保日志输出
	time.Sleep(1 * time.Second)
}

// pppoeDiscovery executes PPPoE discovery and returns a PPPoE session ID.
func pppoeDiscovery(ctx context.Context, conn net.PacketConn) (concentrator net.HardwareAddr, sessionID uint16, err error) {
	deadline, hasDeadline := ctx.Deadline()

	var (
		from   net.Addr
		cookie []byte
	)

	// Broadcast PADIs, looking for a PPPoE concentrator.
	for concentrator == nil && (!hasDeadline || time.Now().Before(deadline)) {
		// Send a PADI, asking concentrators for a session offer.
		if err := sendPADI(conn); err != nil {
			return nil, 0, fmt.Errorf("sending PADI packet: %v", err)
		}
		log.Println("PPPoE client send PADI...")
		padoCtx, cancelPADO := context.WithTimeout(ctx, time.Second)
		defer cancelPADO()

		from, cookie, err = readPADO(padoCtx, conn)
		log.Println("PPPoE client receive PADO...")

		if err == nil {
			// We know about a concentrator, move on.
			break
		} else if neterr, ok := err.(net.Error); !ok || !neterr.Timeout() {
			return nil, 0, fmt.Errorf("waiting for PADO: %v", err)
		}
		// Timed out waiting for PADO. Loop back around to (maybe) try
		// again.
	}

	concentrator = from.(*raw.Addr).HardwareAddr

	// Got a concentrator, request a session.
	for !hasDeadline || time.Now().Before(deadline) {
		log.Println("PPPoE client send PADR...")
		if err := sendPADR(conn, from, cookie); err != nil {
			return nil, 0, fmt.Errorf("sending PADR packet: %v", err)
		}

		padsCtx, cancelPADS := context.WithTimeout(ctx, time.Second)
		defer cancelPADS()
		sessionID, err = readPADS(padsCtx, conn, from)
		log.Println("PPPoE client receive PADS...")

		if err == nil {
			// We're done!
			return concentrator, sessionID, nil
		} else if neterr, ok := err.(net.Error); !ok || !neterr.Timeout() {
			return nil, 0, fmt.Errorf("waiting for PADS: %v", err)
		}
		// Timed out waiting for PADS. Loop back around to (maybe) try
		// again.
	}

	// Oops, deadline exceeded :(
	return nil, 0, ctx.Err()
}

// newDiscoveryConn creates a net.PacketConn that can receive PPPoE
// discovery packets.
func newDiscoveryConn(ifName string) (net.PacketConn, error) {
	intf, err := net.InterfaceByName(ifName)
	if err != nil {
		return nil, fmt.Errorf("getting interface %v: %v", ifName, err)
	}
	conn, err := raw.ListenPacket(intf, protoPPPoEDiscovery, &raw.Config{LinuxSockDGRAM: true})
	if err != nil {
		return nil, fmt.Errorf("creating PPPoE Discovery listener: %v", err)
	}
	return conn, nil
}

// sendPADI broadcasts a PADI packet. While trivial, it's separated
// out so tests can invoke it.
func sendPADI(conn net.PacketConn) error {
	pkt := &discoveryPacket{
		Code: pppoePADI,
		Tags: map[int][]byte{
			pppoeTagServiceName: []byte("WAGF"),
			pppoeTagHostUniq:    []byte("433e0000"),
		},
	}
	// ethernetBroadcast is the Ethernet broadcast address.
	ethernetBroadcast := &raw.Addr{
		HardwareAddr: net.HardwareAddr{0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
	}
	_, err := conn.WriteTo(encodeDiscoveryPacket(pkt), ethernetBroadcast)
	return err
}

// readPADO waits to receive a valid PPPoE Active Discovery Offer
// (PADO) packet, and returns relevant information from it.
func readPADO(ctx context.Context, conn net.PacketConn) (concentratorAddr net.Addr, cookie []byte, err error) {
	var b [pppoeBufferLen]byte

	if deadline, ok := ctx.Deadline(); ok {
		conn.SetReadDeadline(deadline)
		defer conn.SetReadDeadline(time.Time{})
	}

	for {
		n, from, err := conn.ReadFrom(b[:])
		if err != nil {
			return nil, nil, err
		}

		cookie, err := parsePADO(b[:n])

		if err == nil {
			return from, cookie, nil
		}

		// Not a valid PADO, keep waiting
	}
}

// parsePADO parses a raw PADO packet and extracts the PPPoE cookie.
func parsePADO(buf []byte) (cookie []byte, err error) {
	pkt, err := parseDiscoveryPacket(buf)
	if err != nil {
		return nil, err
	}
	if pkt.Code != pppoePADO {
		return nil, errors.New("not a PADO packet")
	}
	if pkt.SessionID != 0 {
		return nil, errors.New("non-zero session ID")
	}

	// Note, not having a cookie is fine. Its function is similar to
	// syncookies, an anti-DoS measure at the concentrator. If the
	// concentrator doesn't care, then neither do we.
	return pkt.Tags[pppoeTagCookie], nil
}

func sendPADR(conn net.PacketConn, concentrator net.Addr, cookie []byte) error {
	pkt := &discoveryPacket{
		Code: pppoePADR,
		Tags: map[int][]byte{
			pppoeTagServiceName: []byte("WAGF"),
			pppoeTagHostUniq:    []byte("433e0000"),
		},
	}
	if len(cookie) != 0 {
		pkt.Tags[pppoeTagCookie] = cookie
	}
	_, err := conn.WriteTo(encodeDiscoveryPacket(pkt), concentrator)
	return err
}

func readPADS(ctx context.Context, conn net.PacketConn, concentrator net.Addr) (sessionID uint16, err error) {
	var b [pppoeBufferLen]byte

	if deadline, ok := ctx.Deadline(); ok {
		conn.SetReadDeadline(deadline)
		defer conn.SetReadDeadline(time.Time{})
	}
	for {
		n, from, err := conn.ReadFrom(b[:])
		if err != nil {
			return 0, err
		}

		if concentrator.String() != from.String() {
			// Wrong peer, keep waiting
			continue
		}

		sessionID, err = parsePADS(b[:n])
		if err == nil {
			return sessionID, nil
		}

		// Not a valid PADO, keep waiting
	}
}

func parsePADS(buf []byte) (sessionID uint16, err error) {
	pkt, err := parseDiscoveryPacket(buf)
	if err != nil {
		return 0, err
	}
	if pkt.Code != pppoePADS {
		return 0, errors.New("not a PADS packet")
	}
	return pkt.SessionID, nil
}

func readPADT(conn net.PacketConn, concentrator net.HardwareAddr, sessionID uint16) error {
	var b [pppoeBufferLen]byte

	for {
		n, from, err := conn.ReadFrom(b[:])
		if err != nil {
			return err
		}

		if concentrator.String() != from.String() {
			// Wrong peer, keep waiting
			continue
		}

		pkt, err := parseDiscoveryPacket(b[:n])
		if err != nil {
			// Bad packet, keep waiting
			continue
		}

		if pkt.Code != pppoePADT || pkt.SessionID != sessionID {
			// Not a PADT meant for our session. This socket receives
			// all PPPoE traffic, so we could be receiving a different
			// session's PADT. Keep waiting.
			continue
		}

		// Got a PADT.
		return nil
	}
}

func sendPADT(conn net.PacketConn, concentrator net.HardwareAddr, sessionID uint16) error {
	pkt := &discoveryPacket{
		Code:      pppoePADT,
		SessionID: sessionID,
	}
	_, err := conn.WriteTo(encodeDiscoveryPacket(pkt), &raw.Addr{concentrator})
	conn.Close()
	return err
}

// discoveryPacket is a parsed PPPoE Discovery packet.
type discoveryPacket struct {
	// Code is the kind of PPPoE packet.
	Code int
	// SessionID is the PPPoE session ID. It's zero for all Discovery
	// packets except PADS and PADT.
	SessionID uint16
	// Tags is a collection of key/value pairs attached to the
	// packet. Required/optional tags vary depending on Code.
	Tags map[int][]byte
}

// parseDiscoveryPacket parses a PPPoE Discovery packet into a discoveryPacket.
func parseDiscoveryPacket(pkt []byte) (*discoveryPacket, error) {
	if len(pkt) < 6 {
		return nil, errors.New("packet too short to be PPPoE Discovery")
	}
	if pkt[0] != 0x11 {
		return nil, fmt.Errorf("unknown PPPoE version %x", pkt[0])
	}

	ret := &discoveryPacket{
		Code:      int(pkt[1]),
		SessionID: binary.BigEndian.Uint16(pkt[2:4]),
		Tags:      map[int][]byte{},
	}

	// tlvLen := int(binary.BigEndian.Uint16(pkt[4:6]))
	// pkt = pkt[6:]
	// if tlvLen != len(pkt) {
	// 	return nil, fmt.Errorf("tag array length %v doesn't match remaining packet length %v", tlvLen, len(pkt))
	// }

	// for len(pkt) > 0 {
	// 	if len(pkt) < 4 {
	// 		return nil, fmt.Errorf("%d bytes of trailing garbage at end of packet", len(pkt))
	// 	}

	// 	tagType, tagLen := int(binary.BigEndian.Uint16(pkt[:2])), int(binary.BigEndian.Uint16(pkt[2:4]))
	// 	if len(pkt[4:]) < tagLen {
	// 		return nil, errors.New("tag declared length larger than remaining packet")
	// 	}

	// 	tagValue := pkt[4 : 4+tagLen]
	// 	pkt = pkt[4+tagLen:]

	// 	if tagType == pppoeTagServiceName && tagLen != 0 {
	// 		return nil, errors.New("unexpected non-nil Service-Name tag")
	// 	}

	// 	ret.Tags[tagType] = tagValue
	// }

	return ret, nil
}

// encodeDiscoveryPacket marshals a PPPoE Discovery packet into raw bytes.
func encodeDiscoveryPacket(pkt *discoveryPacket) []byte {
	tlvLen, tlvs := 0, []int{}
	for tlv, val := range pkt.Tags {
		tlvs = append(tlvs, tlv)
		tlvLen += len(val)
	}
	sort.Ints(tlvs)

	var ret bytes.Buffer
	ret.WriteByte(0x11)            // Protocol version 1, packet type 1
	ret.WriteByte(uint8(pkt.Code)) // PPPoE packet code
	binary.Write(&ret, binary.BigEndian, uint16(pkt.SessionID))
	binary.Write(&ret, binary.BigEndian, uint16(tlvLen+(4*len(pkt.Tags))))

	for _, tlv := range tlvs {
		val := pkt.Tags[tlv]
		binary.Write(&ret, binary.BigEndian, uint16(tlv))
		binary.Write(&ret, binary.BigEndian, uint16(len(val)))
		ret.Write(val)
	}

	return ret.Bytes()
}
