package main

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"log"
	"net"
	"sort"

	"github.com/mdlayher/raw"
)

// Constants for PPPoE protocol EtherTypes.
const (
	protoPPPoEDiscovery = 0x8863
	protoPPPoESession   = 0x8864
)

// Constants for PPPoE Discovery packet types.
const (
	pppoePADI = 0x09 // "Hey, any PPPoE concentrators out there?
	pppoePADO = 0x07 // "Hi, I'm a PPPoE concentrator"
	pppoePADR = 0x19 // "Cool, can we set up a PPPoE session?"
	pppoePADS = 0x65 // "Done, here's the session ID!"
	pppoePADT = 0xa7 // "I'm tearing down our session"
)

// Constants for PPPoE Discovery tag types
const (
	pppoeTagServiceName = 0x0101 // Roughly speaking, the name of the ISP.
	pppoeTagACName      = 0x0102 // Roughly speaking, the hostname of the PPPoE concentrator.
	pppoeTagHostUniq    = 0x0103 // A unique identifier generated by the client.
)

// pppoeBufferLen is the maximum size of a PPPoE packet. The spec says
// that PPPoE packets may not exceed the ethernet MTU, which is 1500.
const pppoeBufferLen = 1500

// DiscoveryServer represents a PPPoE Discovery server.
type DiscoveryServer struct {
	conn net.PacketConn
}

// NewDiscoveryServer creates a new PPPoE Discovery server.
func NewDiscoveryServer(ifName string) (*DiscoveryServer, error) {
	intf, err := net.InterfaceByName(ifName)
	if err != nil {
		return nil, fmt.Errorf("getting interface %v: %v", ifName, err)
	}
	conn, err := raw.ListenPacket(intf, protoPPPoEDiscovery, &raw.Config{LinuxSockDGRAM: true})
	if err != nil {
		return nil, fmt.Errorf("creating PPPoE Discovery listener: %v", err)
	}
	return &DiscoveryServer{conn: conn}, nil
}

// Close closes the underlying connection of the DiscoveryServer.
func (s *DiscoveryServer) Close() error {
	return s.conn.Close()
}

// Serve runs the PPPoE Discovery server.
func (s *DiscoveryServer) Serve() error {
	log.Println("PPPoE server is running...")

	for {
		// Wait for and handle PADI packets from clients
		from, padiPacket, err := s.waitForPADI()
		if err != nil {
			log.Printf("Error handling PADI: %v", err)
			continue
		}

		// Send PADO packet to client
		log.Println("PPPoE server send PADO...")
		if err := s.sendPADO(from, padiPacket); err != nil {
			log.Printf("Error sending PADO: %v", err)
			continue
		}

		// Wait for and handle PADR packets from clients
		sessionID, err := s.waitForPADR(from)
		log.Println("PPPoE client receive PADR...")
		if err != nil {
			log.Printf("Error handling PADR: %v", err)
			continue
		}

		// Send PADS packet to client
		log.Println("PPPoE server send PADS...")
		if err := s.sendPADS(from, sessionID); err != nil {
			log.Printf("Error sending PADS: %v", err)
			continue
		}

		// Wait for and handle PADT packets from clients
		err = s.readPADT(from, sessionID)
		if err != nil {
			log.Printf("Error handling PADT: %v", err)
			continue
		}

		log.Printf("Session with client %s ended", from)
	}
}

// waitForPADI waits for PADI packets from clients and returns the source address and the packet itself.
func (s *DiscoveryServer) waitForPADI() (net.Addr, *discoveryPacket, error) {
	var b [pppoeBufferLen]byte
	for {
		n, from, err := s.conn.ReadFrom(b[:])
		if err != nil {
			log.Printf("Error handling ReadFrom: %v", err)
			return nil, nil, err
		}
		pkt, err := parseDiscoveryPacket(b[:n])
		if err != nil {
			log.Printf("Error handling parseDiscoveryPacket: %v", err)
			continue
		}
		if pkt.Code == pppoePADI {
			return from, pkt, nil
		}
	}
}

// sendPADO sends a PADO packet to the client based on ServiceName and Host-Uniq in PADI.
func (s *DiscoveryServer) sendPADO(to net.Addr, padi *discoveryPacket) error {
	tags := make(map[int][]byte)

	// Check for Host-Uniq tag in PADI
	hostUniq, hasHostUniq := padi.Tags[pppoeTagHostUniq]
	if hasHostUniq && len(hostUniq) > 0 {
		tags[pppoeTagHostUniq] = hostUniq // Include Host-Uniq if present
	}

	// Check for ServiceName tag in PADI and add additional tags if it's "5G"
	serviceName, hasServiceName := padi.Tags[pppoeTagServiceName]
	if hasServiceName {
		if bytes.Equal(serviceName, []byte("5G")) {
			tags[pppoeTagServiceName] = []byte("5G")
			tags[pppoeTagACName] = []byte("WAGF for 5G-RG")
		} else {
			tags[pppoeTagServiceName] = serviceName
			tags[pppoeTagACName] = []byte("WAGF for FN-RG")
		}

	}

	// If there is no Host-Uniq and ServiceName is not "5G", send a minimal PADO
	if len(tags) == 0 {
		tags = nil // An empty PADO with no tags
	}

	padoPacket := encodeDiscoveryPacket(&discoveryPacket{
		Code: pppoePADO,
		Tags: tags,
	})
	_, err := s.conn.WriteTo(padoPacket, to)
	return err
}

// waitForPADR waits for PADR packets from clients and returns the session ID.
func (s *DiscoveryServer) waitForPADR(from net.Addr) (uint16, error) {
	var b [pppoeBufferLen]byte
	for {
		n, _, err := s.conn.ReadFrom(b[:])
		if err != nil {
			return 0, err
		}
		pkt, err := parseDiscoveryPacket(b[:n])
		if err != nil {
			log.Printf("Error handling waitForPADR parseDiscoveryPacket: %v", err)
			continue
		}
		if pkt.Code == pppoePADR {
			return pkt.SessionID, nil
		}
	}
}

// sendPADS sends a PADS packet to the client.
func (s *DiscoveryServer) sendPADS(to net.Addr, sessionID uint16) error {
	padsPacket := encodeDiscoveryPacket(&discoveryPacket{
		Code:      pppoePADS,
		SessionID: 1,
		Tags: map[int][]byte{
			pppoeTagServiceName: []byte("WAGF"), // Change this according to your ISP
			pppoeTagHostUniq:    []byte("433e0000"),
		},
	})
	_, err := s.conn.WriteTo(padsPacket, to)
	return err
}

// readPADT waits for PADT packets from clients to end the session.
func (s *DiscoveryServer) readPADT(from net.Addr, sessionID uint16) error {
	var b [pppoeBufferLen]byte
	for {
		n, _, err := s.conn.ReadFrom(b[:])
		if err != nil {
			return err
		}
		pkt, err := parseDiscoveryPacket(b[:n])
		if err != nil {
			continue
		}
		if pkt.Code == pppoePADT && pkt.SessionID == sessionID {
			return nil
		}
	}
}

// discoveryPacket is a parsed PPPoE Discovery packet.
type discoveryPacket struct {
	// Code is the kind of PPPoE packet.
	Code int
	// SessionID is the PPPoE session ID. It's zero for all Discovery
	// packets except PADS and PADT.
	SessionID uint16
	// Tags is a collection of key/value pairs attached to the
	// packet. Required/optional tags vary depending on Code.
	Tags map[int][]byte
}

// parseDiscoveryPacket parses a PPPoE Discovery packet into a discoveryPacket.
func parseDiscoveryPacket(pkt []byte) (*discoveryPacket, error) {
	if len(pkt) < 6 {
		return nil, errors.New("packet too short to be PPPoE Discovery")
	}
	if pkt[0] != 0x11 {
		return nil, fmt.Errorf("unknown PPPoE version %x", pkt[0])
	}

	ret := &discoveryPacket{
		Code:      int(pkt[1]),
		SessionID: binary.BigEndian.Uint16(pkt[2:4]),
		Tags:      map[int][]byte{},
	}

	// tlvLen := int(binary.BigEndian.Uint16(pkt[4:6]))
	pkt = pkt[6:]
	// if tlvLen != len(pkt) {
	// 	return nil, fmt.Errorf("Tag array length %v doesn't match remaining packet length %v", tlvLen, len(pkt))
	// }

	for len(pkt) > 0 {
		// if len(pkt) < 4 {
		// 	return nil, fmt.Errorf("%d bytes of trailing garbage at end of packet", len(pkt))
		// }

		tagType, tagLen := int(binary.BigEndian.Uint16(pkt[:2])), int(binary.BigEndian.Uint16(pkt[2:4]))
		if len(pkt[4:]) < tagLen {
			return nil, errors.New("tag declared length larger than remaining packet")
		}

		tagValue := pkt[4 : 4+tagLen]
		pkt = pkt[4+tagLen:]

		ret.Tags[tagType] = tagValue
	}

	return ret, nil
}

// encodeDiscoveryPacket marshals a PPPoE Discovery packet into raw bytes.
func encodeDiscoveryPacket(pkt *discoveryPacket) []byte {
	tlvLen, tlvs := 0, []int{}
	for tlv, val := range pkt.Tags {
		tlvs = append(tlvs, tlv)
		tlvLen += len(val)
	}
	sort.Ints(tlvs)

	var ret bytes.Buffer
	ret.WriteByte(0x11)            // Protocol version 1, packet type 1
	ret.WriteByte(uint8(pkt.Code)) // PPPoE packet code
	binary.Write(&ret, binary.BigEndian, uint16(pkt.SessionID))
	binary.Write(&ret, binary.BigEndian, uint16(tlvLen+(4*len(pkt.Tags))))

	for _, tlv := range tlvs {
		val := pkt.Tags[tlv]
		binary.Write(&ret, binary.BigEndian, uint16(tlv))
		binary.Write(&ret, binary.BigEndian, uint16(len(val)))
		ret.Write(val)
	}

	return ret.Bytes()
}

func main() {
	// Create a new PPPoE Discovery server
	server, err := NewDiscoveryServer("ens33")
	if err != nil {
		log.Fatalf("Failed to create PPPoE Discovery server: %v", err)
	}
	defer server.Close()

	// Run the server
	if err := server.Serve(); err != nil {
		log.Fatalf("PPPoE Discovery server error: %v", err)
	}
}
